**要实现二级缓存看Demos**

---

**包**

    antlr-2.7.7.jar
    byte-buddy-1.8.0.jar
    classmate-1.3.0.jar
    dom4j-1.6.1.jar
    hibernate-commons-annotations-5.0.3.Final.jar
    hibernate-core-5.3.0.Final.jar
    hibernate-hikaricp-5.3.0.Final.jar
    HikariCP-3.1.0.jar
    jandex-2.0.3.Final.jar
    javassist-3.22.0-GA.jar
    javax.persistence-api-2.2.jar
    jboss-logging-3.3.2.Final.jar
    jboss-transaction-api_1.2_spec-1.0.1.Final.jar
    mysql-connector-java-5.1.39-bin.jar
    slf4j-api-1.8.0-beta2.jar
    slf4j-nop-1.8.0-beta2.jar

---


**方言**

方言必须配

- 报错:  

     GenerationTarget encountered exception accepting command : Error executing DDL "create table USERINFO (ID varchar(255) not null, USERNAME varchar(255), PASSWORD varchar(255), primary key (ID)) type=MyISAM" via JDBC Statement

- 解决:  

    > The problem is that the dialect org.hibernate.dialect.MySQLDialect is for MySQL 4.x or earlier. The fragment TYPE=MYISAM that is generated by this dialect was deprecated in MySQL 4.0 and removed in 5.5.
    > 
    > Given that you use MariaDB, you need to use (depending on the version of MariaDB and - maybe - the version of Hibernate) one of:
    > 
    > org.hibernate.dialect.MariaDBDialect
    > org.hibernate.dialect.MariaDB53Dialect
    > If you are using MySQL, or if the above two dialects for MariaDB don't exist in your version of Hibernate:
    > 
    > org.hibernate.dialect.MySQL5Dialect
    > org.hibernate.dialect.MySQL55Dialect
    > org.hibernate.dialect.MySQL57Dialect
   
- MySQL 5.5的方言:

    <property name="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</property>

---
**事务**

Transaction ts = session.beginTransaction();  //后面不需要再ts.begin

---

**数据没有提交**

在默认情况下, hibernate不会自动提交, 
需要 **开启事务** 并提交

---

**getCurrentSession的方法会自动关闭session, 不要再close**

---

**Hibernate+Hikari**

1 导包  

- HikariCP-3.1.0.jar  
- hibernate-hikaricp-5.3.0.Final.jar
- slf4j-api-1.8.0-beta2.jar
- slf4j-nop-1.8.0-beta2.jar

2 配置hibernate.cfg.xml

    <property name="hibernate.connection.provider_class">org.hibernate.hikaricp.internal.HikariCPConnectionProvider</property>

---

**load取值抛异常**

load方法用**getCurrentSession**方式取值时只能在**commit之前**取值, 否则session就会关闭, 抛出异常:

    WARN: HHH000233: Scoping types to session factory org.hibernate.internal.SessionFactoryImpl@5778826f after already scoped org.hibernate.internal.SessionFactoryImpl@5778826f
	Exception in thread "main" org.hibernate.LazyInitializationException: could not initialize proxy [demo1.entity.Userinfo#402881f16373f76a016373f76e0d0000] - no Session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:159)
	at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:272)
	at org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:52)
	at org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95)
	at demo1.entity.Userinfo$HibernateProxy$jJximcWS.getUsername(Unknown Source)
	at demo2.demo2.main(demo2.java:25)

---
**Criteria的创建方式在5.3已更改**
    
    import javax.persistence.criteria.CriteriaQuery,而不是import org.hibernate.criterion.CriteriaQuery!!!

    //旧的已被废弃
	session.createCriteria(User.class) 的创建方式已经被废弃
	//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
	CriteriaBuilder cb = session.getCriteriaBuilder();
	CriteriaQuery<User> query = cb.createQuery(User.class);
	Root<User> user = query.from(User.class);
	query.select(user).where(cb.equal(user.get("name"), "andy"));
	List<User> list = session.createQuery(query).getResultList();

[http://guimingsu.com/blog/2016/11/16/hibernate/](http://guimingsu.com/blog/2016/11/16/hibernate/)

---

**多对多**

报错: id 重复 

原因:　两个方面都进行了关联，　导致插入两次相同的id

解决办法: 只在一方面进行关联 

    package demo5;

	import org.hibernate.Session;
	import org.hibernate.Transaction;
	
	import demo3.utils.HibernateUtils;
	import demo5.entity.Student;
	import demo5.entity.Teacher;

	/*
 	* 级联操作 一对多
 	*/
	public class demo5 {
	public static void main(String[] args) {

		Session session = HibernateUtils.getSession();
		Transaction ts = session.beginTransaction();

		Teacher teacher = new Teacher();
		Teacher teacher1 = new Teacher();

		Student student = new Student();
		Student student1 = new Student();

		teacher.setName("jack");
		teacher1.setName("joy");

		student.setScore(22.0);
		student1.setScore(100.0);

		teacher.getStudents().add(student);
		teacher.getStudents().add(student1);
		teacher1.getStudents().add(student);
		teacher1.getStudents().add(student1);

		//下面的不能加
		// student.getTeachers().add(teacher);
		// student.getTeachers().add(teacher1);
		// student1.getTeachers().add(teacher);
		// student1.getTeachers().add(teacher1);

		session.save(teacher);
		session.save(teacher1);
		session.save(student);
		session.save(student1);

		ts.commit();
	}

	}


---

报错: 

    Exception in thread "main" java.lang.ExceptionInInitializerError
	at demo5.demo5.main(demo5.java:16)
	Caused by: org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister
	at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:123)
	at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:77)
	at org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:137)
	at org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:295)
	at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467)
	at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:708)
	at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:724)
	at demo3.utils.HibernateUtils.<clinit>(HibernateUtils.java:13)

原因: 可能是 hbm.xml中有字段写错 比如名字少个s什么的

---

**一对多或者多对多要用集合**

set bag list(多一个排序)

---
**防止更新丢失**

在PO类中添加private Integer version;  
在hbm.xml中<id></id>标签之后加入<version>  [*一定要在<id></id>之后加入,否则报错* ]

---

**hibernate-ehcache**

官方的 hibernate5.3.0-Final 暂时没有提供EHcache的provider_class  
所以要自己下:  
[https://mvnrepository.com/artifact/org.hibernate/hibernate-ehcache/5.3.0.Final](https://mvnrepository.com/artifact/org.hibernate/hibernate-ehcache/5.3.0.Final)  

ps:看demo!

---

**no session 错误**

**原因:** 设置了lazy=true

**解决办法:** 
1. 迫切: from Customer c left join fetch c.order  
2. Hibernate.initialize(o.getCustomer())  参数为代理对象，即需要填充的对象
3. 配置lazy=false(等同于第二点)   
4. 不提交事务(不推荐)  
5. OpenSessionInView: 创建一个过滤器, 在业务开始之前开启session, 在业务之后(doFilter之后)提交事务. 要在action配置之后配置. 要用currentSession. 缺点:长会话导致事务开启时间太长, 太费资源, 考虑其他方法


---

**用MySQL报错:**

	Unable to create requested service [org.hibernate.engine.jdbc.env.spi.JdbcEnvironment]

**原因可能是:** database没有连上  
**解决方法:** 如果用的是jpa, 可能是MySQL驱动版本太高  (5.5的MySQL --- 5.1.39的驱动)

---

**一对多外键都是null的情况**

原因: 关联时多方没有set一方, Order.setCustomer(customer)

解决: 添加 Order.setCustomer(customer)

---

**JPA的fetch注解没有用**

解决方法: 用hibernate的注解 @Fetch(FetchMode.JOIN)

参考: [https://stackoverflow.com/questions/463349/jpa-eager-fetch-does-not-join](https://stackoverflow.com/questions/463349/jpa-eager-fetch-does-not-join)

----

**Fetch的用法**

用在一端的OneToMany的注解中, 表示多端如何查询: select , join , subSelect

**batch的用法**

谁需要批量加载就写到哪里

一方可以配置多方的batchSize, 写到属性相关的地方(如:list set属性)

多方的配置在多方batchSize, 用jpa注解的话写到多方类名的上面 

---

**hibernate映射配置文件路径**

如果用maven的webapp框架, 将配置文件都写到resource文件后, mapping的映射文件位置只能放到resource文件中(感觉这个resource文件夹不太一样,这是在idea上测试的)

---

**hibernate二级缓存只能用load取得单个缓存数据**

---

**hibernate一对多，多对一**

必备属性：name, class, column  
一：list/set/bag (name)> key(column)> [index](column=新建一列) > one-to-many(class)
多：name, class, column 

---

**表无法创建，提示DDL statement不能执行**

问题: org.springframework.dao.InvalidDataAccessResourceUsageException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not execute statement

原因：使用了保留字导致创建表的时候出错

解决办法：更改列名。

ps：index列为新建的列，不能简单的使用index作为列名，因为它时保留字！！！

---

**hibernate保存最好用saveOrUpdate**

如果只用save，根据id找到User，之后对user进行更改，save之后会重新创建一个对象，并且更改id

改用saveOrUpdate之后就可以避免这个问题

---

**插入多条数据**

问题：当插入同一个对象时只能插入一个，如果有一对多，多对一关联，一的一方的list会增加多个空值和一个非空值。 

解决办法：每次都创建一个对象才能添加

---

**load**

hibernateTemplate的load方法在获取不到数据时返回的不是空，而且不会执行，只有在调用时才会报异常！！！