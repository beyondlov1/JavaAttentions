**包**

    antlr-2.7.7.jar
    byte-buddy-1.8.0.jar
    classmate-1.3.0.jar
    dom4j-1.6.1.jar
    hibernate-commons-annotations-5.0.3.Final.jar
    hibernate-core-5.3.0.Final.jar
    hibernate-hikaricp-5.3.0.Final.jar
    HikariCP-3.1.0.jar
    jandex-2.0.3.Final.jar
    javassist-3.22.0-GA.jar
    javax.persistence-api-2.2.jar
    jboss-logging-3.3.2.Final.jar
    jboss-transaction-api_1.2_spec-1.0.1.Final.jar
    mysql-connector-java-5.1.39-bin.jar
    slf4j-api-1.8.0-beta2.jar
    slf4j-nop-1.8.0-beta2.jar

---


**方言**

方言必须配

- 报错:  

     GenerationTarget encountered exception accepting command : Error executing DDL "create table USERINFO (ID varchar(255) not null, USERNAME varchar(255), PASSWORD varchar(255), primary key (ID)) type=MyISAM" via JDBC Statement

- 解决:  

    > The problem is that the dialect org.hibernate.dialect.MySQLDialect is for MySQL 4.x or earlier. The fragment TYPE=MYISAM that is generated by this dialect was deprecated in MySQL 4.0 and removed in 5.5.
    > 
    > Given that you use MariaDB, you need to use (depending on the version of MariaDB and - maybe - the version of Hibernate) one of:
    > 
    > org.hibernate.dialect.MariaDBDialect
    > org.hibernate.dialect.MariaDB53Dialect
    > If you are using MySQL, or if the above two dialects for MariaDB don't exist in your version of Hibernate:
    > 
    > org.hibernate.dialect.MySQL5Dialect
    > org.hibernate.dialect.MySQL55Dialect
    > org.hibernate.dialect.MySQL57Dialect
   
- MySQL 5.5的方言:

    <property name="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</property>

---
**事务**

Transaction ts = session.beginTransaction();  //后面不需要再ts.begin

---

**getCurrentSession的方法会自动关闭session, 不要再close**

---

**Hibernate+Hikari**

1 导包  

- HikariCP-3.1.0.jar  
- hibernate-hikaricp-5.3.0.Final.jar
- slf4j-api-1.8.0-beta2.jar
- slf4j-nop-1.8.0-beta2.jar

2 配置hibernate.cfg.xml

    <property name="hibernate.connection.provider_class">org.hibernate.hikaricp.internal.HikariCPConnectionProvider</property>

---

**load取值抛异常**

load方法用**getCurrentSession**方式取值时只能在**commit之前**取值, 否则session就会关闭, 抛出异常:

    WARN: HHH000233: Scoping types to session factory org.hibernate.internal.SessionFactoryImpl@5778826f after already scoped org.hibernate.internal.SessionFactoryImpl@5778826f
	Exception in thread "main" org.hibernate.LazyInitializationException: could not initialize proxy [demo1.entity.Userinfo#402881f16373f76a016373f76e0d0000] - no Session
	at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:159)
	at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:272)
	at org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:52)
	at org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95)
	at demo1.entity.Userinfo$HibernateProxy$jJximcWS.getUsername(Unknown Source)
	at demo2.demo2.main(demo2.java:25)

---
**Criteria的创建方式在5.3已更改**
    
    import javax.persistence.criteria.CriteriaQuery,而不是import org.hibernate.criterion.CriteriaQuery!!!

    //旧的已被废弃
	session.createCriteria(User.class) 的创建方式已经被废弃
	//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
	CriteriaBuilder cb = session.getCriteriaBuilder();
	CriteriaQuery<User> query = cb.createQuery(User.class);
	Root<User> user = query.from(User.class);
	query.select(user).where(cb.equal(user.get("name"), "andy"));
	List<User> list = session.createQuery(query).getResultList();

[http://guimingsu.com/blog/2016/11/16/hibernate/](http://guimingsu.com/blog/2016/11/16/hibernate/)

---

**多对多**

报错: id 重复 

原因:　两个方面都进行了关联，　导致插入两次相同的id

解决办法: 只在一方面进行关联 

    package demo5;

	import org.hibernate.Session;
	import org.hibernate.Transaction;
	
	import demo3.utils.HibernateUtils;
	import demo5.entity.Student;
	import demo5.entity.Teacher;

	/*
 	* 级联操作 一对多
 	*/
	public class demo5 {
	public static void main(String[] args) {

		Session session = HibernateUtils.getSession();
		Transaction ts = session.beginTransaction();

		Teacher teacher = new Teacher();
		Teacher teacher1 = new Teacher();

		Student student = new Student();
		Student student1 = new Student();

		teacher.setName("jack");
		teacher1.setName("joy");

		student.setScore(22.0);
		student1.setScore(100.0);

		teacher.getStudents().add(student);
		teacher.getStudents().add(student1);
		teacher1.getStudents().add(student);
		teacher1.getStudents().add(student1);

		//下面的不能加
		// student.getTeachers().add(teacher);
		// student.getTeachers().add(teacher1);
		// student1.getTeachers().add(teacher);
		// student1.getTeachers().add(teacher1);

		session.save(teacher);
		session.save(teacher1);
		session.save(student);
		session.save(student1);

		ts.commit();
	}

	}


---

报错: 

    Exception in thread "main" java.lang.ExceptionInInitializerError
	at demo5.demo5.main(demo5.java:16)
	Caused by: org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister
	at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:123)
	at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:77)
	at org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:137)
	at org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:295)
	at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:467)
	at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:708)
	at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:724)
	at demo3.utils.HibernateUtils.<clinit>(HibernateUtils.java:13)

原因: 可能是 hbm.xml中有字段写错 比如名字少个s什么的

---

**一对多或者多对多要用Set集合**

---
**防止更新丢失**

在PO类中添加private Integer version;  
在hbm.xml中<id></id>标签之后加入<version>  [*一定要在<id></id>之后加入,否则报错* ]

---